---
layout: post
title: Spree
comments: true
---

by: https://ruby-china.org/topics/31191

最近在做`Spree`的定製開發，翻看其中的代碼，發現其中有下面這麼一段代碼信息量是非常的大。所以就想通過這一小段代碼來好好學習一下相關的Ruby知識。

```
# spree/api/lib/spree/api/engine.rb

def self.activate
  Dir.glob(File.join(File.dirname(__FILE__), "../../../app/**/*_decorator*.rb")) do |c|
    Rails.configuration.cache_classes ? require(c) : load(c)
  end
end

config.to_prepare &method(:activate).to_proc
```

就是這樣的一段代碼卻包含了大量的Ruby和Rails的知識。其中最後一行`config.to_prepare &method(:activate).to_proc `是本文重點解釋的對象，接下來我們就一個一個來學習。

#### self.active

`self.activate`方法其實不難理解，這是一個類方法，會在引入Spree的應用中查找`app`目錄下面文件名中帶有`_decorator`的文件，這些文件都是用來定製擴展Spree功能的文件。在這裡，找到後會判斷是否設置了`Rails.configuration.cache_classes`這個選項，一般在開發環境中，該選項是false，這樣當你修改代碼後Rails會自動reload相關的文件。而在產品環境中，該選項為true，因為我們不會在產品環境修改代碼讓Rails自動reload。

後面`require`和`load`的最重要的區別就是，`require`如果發現該文件已經加載過後就不會重新載入，而`load`不管之前是否已經載入都會加載該文件。

重點來了，讓我們看看下面這行信息量巨大的代碼吧。一眼就看明白的同學，請自行繞過！

```
config.to_prepare &method(:activate).to_proc
```

#### method(:activate)

`method`方法來自於`Object`，會在當前的實例(上面的例子就是self)上查找通過參數指定的方法。找到後返回一個`Method`的實例，這個Method的對象就是一個封裝了方法所屬的對象以及該對象的實例變量的閉包。

#### method(:activate).to_proc

接下來就是調用`Method`對象的`to_proc`方法，產生一個對應的`Proc`對象。

#### &method(:activate).to_proc

在`Proc`對象前面加上`&`符號，作為參數傳遞，相當於給方法傳遞了一個`block`，然後方法內部通過`yield`調用`block`，例如：

```
def to_prepare
  yield if block_given?
  puts 'Done prepare!'
end

to_prepare(&proc)
```

相反，如果在接收的`block`參數前面加上`&`符號，那就相當於給方法傳遞了一個`Proc`的對象，然後方法內部通過`proc.call`來調用

```
def config(&block)
  block.call
  puts 'done config!'
end

config do
  puts 'I am block!'
end
```

#### config.to_prepare

這是來自Rails配置裡面功能, 該配置是全局性的，會在所有的initializers運行之後運行。很重要的一點是，該配置中的代碼，在production和test環境中默認只會執行一次，而在開發環境dev中，會在每次修改文件，重新發出請求時，Rails完成reload，在實際進行請求處理之前執行這段代碼。（好繞的流程）

所以，你會看到上面的代碼就是來重新加載一些定製Spree功能的代碼。

在Rails中你還可以手動調用`ActionDispatch::Reloader.to_prepare`來實現同樣地功能。

另外還有一個與之對應的`ActionDispatch::Reloader.to_cleanup`,區別是該`callback`會在請求處理完成後執行。

上面提到開發環境的不同，主要是受到`config.cache_classes`配置的控制。開發環境dev下，該屬性為`false`，所以Rails會發現有文件修改後，自動realod。

#### 實例

介紹完這些基本的知識點後，你可能會覺得還是有點糊塗，為什麼Spree中要這麼做呢？

這種做法其實在Ruby的世界是一種常見的用法，主要就是利用閉包的特點,把相關的邏輯更好的組織和封裝。關於這一點上面Spree的例子不是很完美。

下面有給出一段利用閉包中封裝的實例變量的例子。

```
class MethodTest
  class << self
    attr_accessor :root_path

    def activate
      puts @root_path
      puts helper
    end

    def helper
      "I am helper method. #{@root_path}"
    end
  end
end

def to_prepare
  yield if block_given?
  puts 'Done prepare!'
end

MethodTest.root_path = '/root'
to_prepare &MethodTest.method(:activate).to_proc
```

看完後，有學到新東西嗎？Yes！那就點個💖唄。謝謝
