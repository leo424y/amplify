---
layout: post
title: regexp
---
# 正規表示法

如果你只需要在字串中簡單的搜索文字，不要使用正規表示法：`string['text']`

針對簡單的字串查詢，你可以直接在字串索引中直接使用正規表示法。

```
match = string[/regexp/]             # 獲得匹配正規表示法的內容first_group = string[/text(grp)/, 1] # 或得分組的內容string[/text (grp)/, 1] = 'replace'  # string => 'text replace'
```

當你不需要替結果分組時，使用非分組的群組。

```
/(first|second)/   # 不好/(?:first|second)/ # 好
```

避免使用 `$1-9`，因為它們很難追蹤它們包含什麼。可以使用命名群組來替代。

```
# 不好/(regexp)/ =~ string...process $1# 好/(?<meaningful_var>regexp)/ =~ string...process meaningful_var
```

字元類別只有幾個你需要關心的特殊字元：`^`, `-`, `\`, `]`，所以你不用逃脫字元 `.` 或在 `[]` 的中括號。
小心使用 `^` 與 `$` ，它們匹配的是一行的開始與結束，不是字串的開始與結束。如果你想要匹配整個字串，使用 `\A` 與 `\z`。

(譯註：`\Z` 實為 `/\n?\z/`，使用 `\z` 才能匹配到有含新行的字串的結束)

```
string = "some injection\nusername"string[/^username$/]   # 匹配string[/\Ausername\z/] # 無匹配
```

針對複雜的正規表示法，使用 `x` 修飾符。這讓它們的可讀性更高並且你可以加入有用的註解。只是要小心忽略的空白。

```
regexp = %r{ 
  start         # 一些文字 
  \s            # 空白字元 
  (group)       # 第一組 
  (?:alt1|alt2) # 一些替代方案 
  end
}x
```

針對複雜的替換，`sub` 或 `gsub` 可以與區塊或雜湊來使用。
